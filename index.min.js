/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var Peon = __webpack_require__(5);
var Game = __webpack_require__(4);
var Constants = __webpack_require__(9);
window.oncontextmenu = function ()
{
    return false;
}
window.onload = () => {
  runGame();
}

function runGame(){
  var canvas = document.getElementById('canvas');
  var game = new Game(canvas);
  var unitSize = Constants.gridUnitSize;
  var peon = new Peon(unitSize*10,unitSize*4, game.map.gridUnitSize, 1);
  var peon2 = new Peon(unitSize*9,unitSize*4, game.map.gridUnitSize,1);
  var peon3 = new Peon(unitSize*8,unitSize*4, game.map.gridUnitSize,1);
  game.baseLayer.push(peon);
  game.baseLayer.push(peon2);
  game.baseLayer.push(peon3);
  var enemy = new Peon(unitSize*12,unitSize*4,game.map.gridUnitSize,2);
  game.baseLayer.push(enemy);
  /*setInterval(()=>{
    enemy.moveTo(getRandomArbitrary(0,200), getRandomArbitrary(0,200));
  }, 3000); */
  game._intervalId = setInterval(game.run, 1000 / game.fps);
}


function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(2);

class SelectionRectangle extends GameObject {
  constructor(game) {
    super(0,0,0,0);
    this.game = game;
    this.draw = (ctx,viewport) => {
      if(!this.visible){ return; }
      ctx.strokeStyle='red';
      ctx.lineWidth=1;
      var translatedPos = viewport.convertMapCoordsToDisplayCoords(this.x,this.y);
      ctx.strokeRect(translatedPos.x,translatedPos.y,this.w,this.h);
    };

    this.holding = false;
    this.handleDown = coords => {
      if(!this.holding){
        this.holding = true;
        this.x = coords.x;
        this.y = coords.y;
        this.visible = true;
      }
    }
    document.onmouseup = event => {
      if(event.which == 3){ return;} //right click
      if(this.holding){
        this.game.selectObjectsInRect(this.x,this.y,this.h,this.w, game.localPlayer);
        this.visible = false;
        this.x = 0;
        this.y = 0;
        this.h = 0;
        this.w = 0;
        this.holding = false;
      }
    }
    this.handleMove = coords =>{
      if(this.visible){
        this.w = coords.x - this.x;
        this.h = coords.y - this.y;
        return true;
      }
      return false;
    }

  }
}

module.exports = SelectionRectangle;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(6);
var Constants = __webpack_require__(9);
var Utils = __webpack_require__(3);

class GameObject {
  constructor(x,y,h,w,owner) {
    this.id = Utils.getId();
    var height = h - (h%Constants.gridUnitSize);
    var width = w - (w%Constants.gridUnitSize);
    this.position = new Rectangle(x,y,height,width);
    this.size = {w,h};
    this.visible = false;
    this.owner = owner;
    this.update = map => {
      return this.position;
    };
    this.draw = (ctx, mapper) => {
    };
    this.printPosition = () => {
        console.log('at ' + this.position.x + ','+this.position.y);
    };
    this.rightClickAction = event => {
      console.log('right click');
    }
    this.select = () => {
      console.log('select');
    }
    this.deselect = () => {
      console.log('deselect');
    }
    this.alive = () => {
      return true;
    }
  }
}
module.exports = GameObject;


/***/ }),
/* 3 */
/***/ (function(module, exports) {


module.exports.getCanvasCoords = function(event, canvas) {
  var style = canvas.currentStyle || window.getComputedStyle(canvas);
  var leftMargin = style.marginLeft.slice(0, -2);
  var topMargin = style.marginTop.slice(0, -2);
  var modelX = Math.round( (event.clientX- leftMargin) * (canvas.width / canvas.offsetWidth));
  var modelY = Math.round( (event.clientY - topMargin) * (canvas.height / canvas.offsetHeight));
  return {x:modelX, y:modelY};
}


var idCounter = 0;
module.exports.getId = () => {
  return idCounter++;
}


module.exports.getFaceDirection = (position,target) =>{
  var targetY = target.y;
  var targetX = target.x;
  var margin = 0;
    if(target.x -margin > position.x){
      //target is to the right
      if(targetY - margin > position.y){
        return 'SE';
      }
      else if(targetY + margin < position.y){
        return 'NE';
      }
      else {
        return 'E';
      }
    }
    else if(target.x + margin < position.x){
      //target is to the left
      if(targetY - margin > position.y){
        return 'SW';
      }
      else if(targetY + margin < position.y){
        return 'NW';
      } else{
        return 'W';
      }
    }
    else{
      //target is at same X
      if(targetY + margin > position.y){
        return 'S';
      }
      else if(targetY - margin < position.y){
        return 'N';
      }
    }
    return null;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var utils = __webpack_require__(3);
var SelectionRectangle = __webpack_require__(1);
var Rectangle = __webpack_require__(6);
var Viewport = __webpack_require__(7);
var Map = __webpack_require__(8);

module.exports = function Game(canvas){
  this.canvas = canvas;
  this.map = new Map(900,900);
  this.viewport = new Viewport(canvas, this.map, {x:100,y:100});
  this.ctx = canvas.getContext('2d');
  this.ctx.imageSmoothingEnabled = false;
  this.ctx.translate(0.5, 0.5);
  this.localPlayer = 1;
  this.fps = 60;
  this.baseLayer = [];
  this.topLayer = [];
  this.selected = [];
  this.update = () => {
    var dead = this.baseLayer.filter(o => {return !o.alive();});
    dead.forEach(obj =>{
      this.map.removeObjectFromGrid(obj.position);
    });
    this.baseLayer = this.baseLayer.filter(o => {return o.alive();});
    this.baseLayer.forEach(obj => {
      var preUpdatePosition = new Rectangle(obj.position.x,obj.position.y,obj.position.h,obj.position.w);
      var newPosition = obj.update(this.map);
      //check map collision
      if(!this.map.isObjectInside(newPosition)){
        obj.position = preUpdatePosition;
        return;
      }
      this.map.moveObjectInGrid(preUpdatePosition, newPosition, obj.id);
    });
    this.topLayer = this.topLayer.filter(o => {return o.alive();});
    this.topLayer.forEach(obj => {
      obj.update();
    });
  }
  this.draw = () => {
    this.ctx.clearRect(-0.5, -0.5, this.canvas.width, this.canvas.height);
    var context = this.ctx;
    this.baseLayer.forEach(obj => {
      obj.draw(context, this.viewport);
    });
    this.topLayer.forEach(obj => {
      obj.draw(context, this.viewport);
    });
  }
  this.run = () => {
    this.update();
    this.draw();
    this.viewport.updateScroll();
  };

  this.selectObjectsInRect = (x,y,h,w,player) => {
    //var translatedPosition = this.viewport.convertMapCoordsToDisplayCoords(x, y);
    this.selected.map(obj =>{ obj.deselect(); });
    this.selected.length = 0;
    var selectionRect = new Rectangle(x,y,h,w);
    var toSelect = this.baseLayer.filter(obj => {
      return obj.owner == player && selectionRect.intersectRect(obj.position);
    });
    toSelect.forEach(obj => { obj.select(); });
    this.selected.push(...toSelect)
  }

  document.onmousedown = event => {
    var canvasCoords = utils.getCanvasCoords(event, this.canvas);
    var coords = this.viewport.convertDisplayCoordsToMapCoords(canvasCoords.x,canvasCoords.y)
    if(event.which !== 3){
      this.selectionRectangle.handleDown(coords);
      return;
    }
    if(event.which == 3){
      //do right click actions here
      var affectedObject = this.baseLayer.find(obj => { return obj.position.contains(coords.x, coords.y); })
      this.selected.forEach(obj => {
        obj.rightClickAction(coords, affectedObject);
      })
    }
  }
  document.onmousemove = event => {
    var coords = utils.getCanvasCoords(event, this.canvas);
    var translatedCoords = this.viewport.convertDisplayCoordsToMapCoords(coords.x,coords.y)
    if(!this.selectionRectangle.handleMove(translatedCoords)){
      this.viewport.handleMove(coords);
    }
  }
  this.selectionRectangle = new SelectionRectangle(this);
  this.topLayer.push(this.selectionRectangle);
  this.topLayer.push(this.map)
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(2);
var Utils = __webpack_require__(3);

class Peon extends GameObject {
  constructor(x,y, gridUnitSize, owner) {
    super(x,y,gridUnitSize*1,gridUnitSize*1, owner);
    this.image = new Image();
    this.image.src = 'images/peon_reversed.png';
    var that = this;
    this.image.onload = function() {
      that.render = true;
    };
    this.imageSize = 50;
    this.frameCount = 4;
    this.spriteHorizontalOffset = 0;
    this.spriteVerticalOffset = 0;
    this.updatesPerFrame = 20;
    this.animationUpdateCounter = 0;
    this.animationFrameIndex = 0;
    this.directionOffset = 0;
    this.moving = 0;
    this.speedFactor = 0.9; //movement per update
    this.visible = true;
    this.render = false;
    this.directionX = 0;
    this.directionY = 0;
    this.currentWaypoints = [];
    this.range = 2;
    this.damage = 5;
    this.hitpoints = 100;
    this.lastAttack = 0;
    this.secondsPerAttack = 0.4;
    this.draw = (ctx, viewport) => {
      if(!this.visible || !this.render){ return; }
      var translatedPosition = viewport.convertMapCoordsToDisplayCoords(this.position.x, this.position.y);
      this.updatesPerFrame = this.moving() ? 10 : 60;
      ctx.drawImage(
        this.image,
        this.directionOffset,
        this.animationFrameIndex * (this.imageSize-10),
        this.imageSize,
        this.imageSize-15,
        translatedPosition.x,
        translatedPosition.y,
        this.position.w* (this.flipSprite ? -1 : 1),
        this.position.h
      );
      ctx.fillStyle=this.color;
      if(this.selected){
        ctx.fillStyle = 'green';
        ctx.fillRect(translatedPosition.x,translatedPosition.y - 3,this.position.w,3);
      }
      this.drawPath(ctx,viewport, translatedPosition);

    };

    this.moving = () =>{
      return this.currentWaypoints.length > 0;
    }

    this.getDirectionInfo = map =>{
      if(this.currentWaypoints.length < 1){
          return {offset: this.imageSize * Math.floor((Math.random() * (4 - 0)))};
      }
      var gridPosition = map.calculateGridPositionsFromPosition(this.position)[0];
      var positionAndTargetSame = this.currentWaypoints[0].x == gridPosition.x && this.currentWaypoints[0].y == gridPosition.y
      var target = positionAndTargetSame && this.currentWaypoints.length > 2 ? this.currentWaypoints[1] : this.currentWaypoints[0];
      var direction = Utils.getFaceDirection(gridPosition, target);
      var offset = 0;
      switch(direction){
        case 'N': offset = 0; break;
        case 'NE': offset = 1; break;
        case 'E': offset = 2; break;
        case 'SE': offset = 3; break;
        case 'S': offset = 4; break;
        case 'SW': offset = 5; break;
        case 'W': offset = 6; break;
        case 'NW': offset = 7; break;
        case null: offset = Math.floor(this.directionOffset/this.imageSize); break;
      }
      return {offset: this.imageSize * offset};
    }

    this.drawPath = (ctx,viewport, translatedPosition) =>{
      if(this.selected && this.currentWaypoints.length > 1){
        ctx.fillStyle='gray';
        ctx.beginPath();
        ctx.moveTo(translatedPosition.x + this.position.w/2,translatedPosition.y + this.position.h/2);
        this.currentWaypoints.forEach(wp =>{
          var trwp = viewport.convertMapCoordsToDisplayCoords(wp.mapX, wp.mapY);
          ctx.lineTo(trwp.x + this.position.w/2,trwp.y+ this.position.h/2);
        });
        ctx.stroke();
      }
    }

    this.update = map => {
      if(this.target){
        this.tryAttack();
      }

      if(this.moveTarget){
        if(this.currentWaypoints.length == 0 || map.isBlocked(this.currentWaypoints[0], this.position, this.id)){
          this.createPath(map, this.moveTarget);
        }
        if(this.currentWaypoints.length > 0){
          this.moveTowards(this.currentWaypoints[0].mapX, this.currentWaypoints[0].mapY);
        }
      }
      this.animationUpdateCounter++;
      if(this.animationUpdateCounter > this.updatesPerFrame){
        this.animationFrameIndex = (this.animationFrameIndex + 1) % (this.frameCount +1);
        this.animationUpdateCounter = 0;
        var directionInfo = this.getDirectionInfo(map);
        this.directionOffset = directionInfo.offset;
        if(!this.moving()){ this.animationFrameIndex = 0;}
      }

      return this.position;
    };

    this.createPath = (map, target) =>{
      var toX = target.x;
      var toY = target.y;
      this.currentWaypoints = map.calculatePath(this.position, toX, toY);
    };

    this.moveTo = (x,y) => {
      this.moveTarget = {x,y};
      this.currentWaypoints.length = 0;
    };
    this.moveTowards = (x,y) => {
      var isAtX = Math.abs(this.position.x - x) < 0.5;
      var isAtY = Math.abs(this.position.y - y) < 0.5;
      if( isAtX && isAtY){
        this.currentWaypoints.splice(0,1);
        if(this.currentWaypoints.length == 0){ this.moveTarget = null;}
        return;
      }
      if(!isAtX){
        this.position.x += this.speedFactor * (this.position.x > x ? -1 : 1);
      }
      if(!isAtY){
        this.position.y += this.speedFactor * (this.position.y > y ? -1 : 1);
      }
    }

    this.tryAttack = () => {
      var xInRange = Math.abs(this.position.middleX() - this.target.position.middleX()) <= this.range;
      var yInRange = Math.abs(this.position.middleY() - this.target.position.middleY()) <= this.range;
      var attackSpeedTimerUp = (Date.now() - this.lastAttack) /1000 > this.secondsPerAttack;
      if( xInRange && yInRange && attackSpeedTimerUp){
        this.currentWaypoints.splice(0,1);
        this.attackCurrentTarget();
        return;
      }
    }

    this.attackCurrentTarget = () => {
      if(this.target.alive()){
        this.target.hit(this.damage);
        this.lastAttack = Date.now();
        if(!this.target.alive()){
          this.target = null;
        }
      }
    }

    this.hit = dmg => {
      console.log('hit for ' + dmg + ' damage');
      this.hitpoints -= dmg;
    }

    this.alive = () => {
      return this.hitpoints > 0;
    }

    this.attackTo = object => {
      this.target = object;
      this.moveTarget = object;
      this.moveTo(this.target.position.x, this.target.position.y);
    }

    this.rightClickAction = (pos,object) =>{
      if(object){
        if(object.owner != this.owner){
          this.attackTo(object);
          return;
        }
      }
      this.target = null;
      this.moveTo(pos.x, pos.y);
    }

    this.select = () => {
      this.selected = true;
    }

    this.deselect = () => {
      this.selected = false;
    }
  }
}

module.exports = Peon;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = function Rectangle(x,y,h,w){
  this.h = h;
  this.w = w;
  this.x = x;
  this.y = y;
  this.left = () => { return this.w < 0 ? this.x + this.w : this.x;};
  this.top = () => { return this.h < 0 ? this.y + this.h : this.y;};
  this.bottom = () => { return this.h < 0 ? this.y : this.y + this.h;};
  this.right = () => { return this.w < 0 ? this.x :  this.x + this.w;};
  this.middleX = () => { return this.left() + ((this.right() - this.left()) /2);};
  this.middleY = () => { return this.left() + ((this.bottom() - this.top()) /2);};

  this.contains = (x,y) =>{
    return this.left() <= x && x <= this.right() &&
           this.top() <= y && y <= this.bottom();
  }
  this.intersectRect = function(other) {
    return !(other.left() > this.right() ||
             other.right() < this.left() ||
             other.top() > this.bottom() ||
             other.bottom() < this.top());
  }
}


/***/ }),
/* 7 */
/***/ (function(module, exports) {


module.exports = function Viewport(canvas, map, startCorner){

  this.map = map;
  this.canvas = canvas;
  this.scrollSpeed = 5;
  this.scrollMargin = 60;
  this.viewportCorner = {x:startCorner.x,y:startCorner.y};
  this.convertMapCoordsToDisplayCoords = (x,y) => {
    return {x:(x - this.viewportCorner.x), y:(y-this.viewportCorner.y)};
  }

  this.convertDisplayCoordsToMapCoords = (x,y) => {
    return {x:(x + this.viewportCorner.x), y:(y+this.viewportCorner.y)};
  }

  this.updateScroll = () => {
    if(this.mouseX > canvas.width - this.scrollMargin && this.mouseX < canvas.width){ this.scrollRight();}
    if(this.mouseY > canvas.height - this.scrollMargin && this.mouseY < canvas.height){ this.scrollDown();}
    if(this.mouseX < this.scrollMargin && this.mouseX > 0){ this.scrollLeft();}
    if(this.mouseY < this.scrollMargin && this.mouseY > 0){ this.scrollUp();}
  }

  this.handleMove = coords =>{
    this.mouseX = coords.x;
    this.mouseY = coords.y;
  }

  this.scrollRight = () => {
    this.scroll(this.scrollSpeed,0);
  }

  this.scrollDown = () => {
    this.scroll(0,this.scrollSpeed);
  }

  this.scrollLeft = () => {
    this.scroll(-this.scrollSpeed,0);
  }

  this.scrollUp = () => {
    this.scroll(0,-this.scrollSpeed);
  }

  this.scroll = (x,y) => {
    if(this.viewportCorner.x < -50 && x < 0){
      //skip x
    }
    else if(this.viewportCorner.x + this.canvas.width -50 > this.map.position.w && x > 0){
      //skip x
    } else{
      this.viewportCorner.x += x;
    }

    if(this.viewportCorner.y < -25 && y < 0){
      //skip y
    }
    else if(this.viewportCorner.y + this.canvas.height - 25 > this.map.position.h && y > 0){
      //skip y
    } else{
      this.viewportCorner.y += y;
    }
  }
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(2);
var Constants = __webpack_require__(9);

class Map extends GameObject {
  constructor(h,w) {
    var height = h - (h%Constants.gridUnitSize);
    var width = w - (w%Constants.gridUnitSize);
    super(0,0,height,width);
    this.gridUnitSize = Constants.gridUnitSize;
    this.color = 'black';
    this.visible = true;
    this.grid = [];
    this.debug = false;
    this.searchPatternDebugs = [];
    for(var i=0; i<width/this.gridUnitSize; i++) {
        this.grid[i] = new Array(height/this.gridUnitSize);
    }
    this.draw = (ctx, viewport) => {
      if(!this.visible){ return; }
      ctx.strokeStyle=this.color;
      var translatedPosition = viewport.convertMapCoordsToDisplayCoords(this.position.x, this.position.y);
      ctx.strokeRect(translatedPosition.x,translatedPosition.y,this.position.h,this.position.w);
      if(this.debug){
        for(var x = 0; x < this.grid.length; x++) {
          for(var y = 0; y < this.grid[x].length; y++) {
            var gridPos = viewport.convertMapCoordsToDisplayCoords(this.gridUnitSize * x, this.gridUnitSize * y);
            ctx.strokeStyle='black';
            ctx.strokeRect(gridPos.x,gridPos.y,this.gridUnitSize,this.gridUnitSize);
            if(this.grid[x][y]){
              ctx.strokeStyle='purple';
              ctx.strokeRect(gridPos.x + 2,gridPos.y + 2,this.gridUnitSize-4,this.gridUnitSize-4);
            }
          }
        }
        this.searchPatternDebugs.forEach(sp =>{
          var gridPos = viewport.convertMapCoordsToDisplayCoords(this.gridUnitSize * sp.x, this.gridUnitSize * sp.y);
          ctx.font="7px Helvetica";
          ctx.fillStyle = 'black';
          ctx.fillText(sp.f, gridPos.x + 1, gridPos.y+10);
        });
      }

    };

    this.isObjectInside = position =>{
      if(position.x < -0.5  || position.x + position.w > this.position.w+0.5){return false;}
      if(position.y < -0.5  || position.y + position.h > this.position.h+0.5){return false;}
      return true;
    };

    this.removeObjectFromGrid = position =>{
      var positions = this.calculateGridPositionsFromPosition(position);
      positions.forEach(pos =>{
        this.grid[pos.x][pos.y] = false;
      });
    };

    this.moveObjectInGrid = (oldPosition, newPosition, id) =>{
      var oldPositions = this.calculateGridPositionsFromPosition(oldPosition);
      var newPositions = this.calculateGridPositionsFromPosition(newPosition);
      oldPositions.forEach(pos =>{
        this.grid[pos.x][pos.y] = false;
      });
      newPositions.forEach(pos =>{
        this.grid[pos.x][pos.y] = id;
      });
    };

    this.isBlocked = (toCheck, currentPos, id) =>{
      var currentGridPositions = this.calculateGridPositionsFromPosition(currentPos);
      var isBlocked = this.grid[toCheck.x][toCheck.y] && this.grid[toCheck.x][toCheck.y] !== id;
      return isBlocked;
    };

    this.calculateGridPositionsFromPosition = position =>{
      var positions = [];
      var mapX = position.x+1;
      var mapY = position.y+1;
      var mapWidth = position.w;
      var mapHeight = position.h;
      var gridX = (mapX - (mapX% this.gridUnitSize))/ this.gridUnitSize;
      var gridY = (mapY - (mapY% this.gridUnitSize)) / this.gridUnitSize;
      var gridWidth = mapWidth / this.gridUnitSize;
      var gridHeight = mapHeight / this.gridUnitSize;

      for(var i = 0;i<gridWidth;i++){
        for(var j = 0;j<gridHeight;j++){
          positions.push({x:gridX + i, y:gridY + j});
        }
      }
      return positions;
    };

    this.calculatePath = (position, toX, toY) =>{
      this.searchPatternDebugs.length = 0;
      var gridWidth = position.w / this.gridUnitSize;
      var gridHeight = position.h / this.gridUnitSize;

      var fromGridX = (position.x - (position.x % this.gridUnitSize))/ this.gridUnitSize;
      var fromGridY = (position.y - (position.y % this.gridUnitSize)) / this.gridUnitSize;
      var toGridX = (toX - (toX % this.gridUnitSize))/ this.gridUnitSize;
      var toGridY = (toY - (toY % this.gridUnitSize))/ this.gridUnitSize;

      if(this.grid[toGridX][toGridY]){
        var closestPossiblePoint = this.getClosestPoint(fromGridX,fromGridY,toGridX,toGridY);
        toGridX = closestPossiblePoint.x;
        toGridY = closestPossiblePoint.y;
      }

      var openList = [];
      var grid = this.createSearchGrid();
      openList.push({x:fromGridX, y:fromGridY,g:0,f:0});
      while(openList.length > 0){
        var lowInd = 0;
        for(var i=0; i<openList.length; i++) {
          if(openList[i].f < openList[lowInd].f) { lowInd = i; }
        }
        var currentNode = openList[lowInd];
        currentNode.searched = true;
        if(this.debug){ this.searchPatternDebugs.push(currentNode); }

        if(currentNode.x == toGridX && currentNode.y == toGridY) {
          var curr = currentNode;
          var ret = [];
          while(curr.parent) {
            ret.push(curr);
            curr = curr.parent;
          }
          var toRet = ret.reverse();
          //toRet.shift();
          return toRet;
        }

        openList = openList.filter(item => item !== currentNode)
        var neighbors = this.neighbors(grid, currentNode);
        for(var i=0; i<neighbors.length;i++) {
         var neighbor = neighbors[i];
         if(neighbor.searched || neighbor.wall) {
           // not a valid node to process, skip to next neighbor
           continue;
         }

         // g score is the shortest distance from start to current node, we need to check if
         //   the path we have arrived at this neighbor is the shortest one we have seen yet
         var gScore = currentNode.g + 1; // 1 is the distance from a node to it's neighbor
         var gScoreIsBest = false;


         if(openList.indexOf(neighbor) < 0) {
           // This the the first time we have arrived at this node, it must be the best
           // Also, we need to take the h (heuristic) score since we haven't done so yet
           gScoreIsBest = true;
           neighbor.h = this.manhattan({x:neighbor.x, y:neighbor.y}, {x:toGridX, y:toGridY});
           openList.push(neighbor);
         }
         else if(gScore < neighbor.g) {
           // We have already seen the node, but last time it had a worse g (distance from start)
           gScoreIsBest = true;
         }

         if(gScoreIsBest) {
           // Found an optimal (so far) path to this node.   Store info on how we got here and
           //  just how good it really is...
           neighbor.parent = currentNode;
           neighbor.g = gScore;
           neighbor.f = neighbor.g + neighbor.h;
           neighbor.debug = "F: " + neighbor.f + "<br />G: " + neighbor.g + "<br />H: " + neighbor.h;
         }
        }
      }
      return [];
    };

    this.getClosestPoint = (fromGridX,fromGridY,toGridX,toGridY) =>{
      var yOffset = 0;
      var xOffset = 0;
      if(fromGridY < toGridY){
        yOffset = -1;
      }
      if(fromGridY > toGridY){
        yOffset = 1;
      }
      if(fromGridX < toGridX){
        //from above
        xOffset = -1;
      }
      if(fromGridX > toGridX){
        xOffset = 1;
      }
      return {x:toGridX + xOffset, y:toGridY+yOffset};
    };

    this.createSearchGrid = () => {
      var searchGrid = [];
      for(var x = 0; x < this.grid.length; x++) {
        searchGrid[x] = [];
        for(var y = 0; y < this.grid[x].length; y++) {
          searchGrid[x][y] = {};
          searchGrid[x][y].x = x;
          searchGrid[x][y].y = y;
          searchGrid[x][y].mapX = x * this.gridUnitSize;
          searchGrid[x][y].mapY = y * this.gridUnitSize;
          searchGrid[x][y].f = 0;
          searchGrid[x][y].g = 0;
          searchGrid[x][y].h = 0;
          searchGrid[x][y].searched = false;
          searchGrid[x][y].parent = null;
          searchGrid[x][y].wall = this.grid[x][y];
        }
      }
      return searchGrid;
  },

    this.neighbors = (grid, node) =>{
      var ret = [];
      var x = node.x;
      var y = node.y;
      if(grid[x-1] && grid[x-1][y]) {
          ret.push(grid[x-1][y]);
      }
      if(grid[x+1] && grid[x+1][y]) {
          ret.push(grid[x+1][y]);
      }
      if(grid[x][y-1] && grid[x][y-1]) {
          ret.push(grid[x][y-1]);
      }
      if(grid[x][y+1] && grid[x][y+1]) {
          ret.push(grid[x][y+1]);
      }
      // Southwest
      if(grid[x-1] && grid[x-1][y-1]) {
        ret.push(grid[x-1][y-1]);
      }

      // Southeast
      if(grid[x+1] && grid[x+1][y-1]) {
          ret.push(grid[x+1][y-1]);
      }

      // Northwest
      if(grid[x-1] && grid[x-1][y+1]) {
          ret.push(grid[x-1][y+1]);
      }

      // Northeast
      if(grid[x+1] && grid[x+1][y+1]) {
          ret.push(grid[x+1][y+1]);
      }
      return ret;
    };

    this.manhattan = (pos0, pos1) =>{
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      return d1 + d2;
    };
  }
}

module.exports = Map;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports.gridUnitSize = 40;


/***/ })
/******/ ]);