/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var Peon = __webpack_require__(5);
var Game = __webpack_require__(4);
window.oncontextmenu = function ()
{
    return false;
}
window.onload = () => {
  runGame();
}

function runGame(){
  var canvas = document.getElementById('canvas');
  var game = new Game(canvas);
  var peon = new Peon(110,110, 1);
  var peon2 = new Peon(150,110, 1);
  var peon3 = new Peon(190,110, 1);
  game.baseLayer.push(peon);
  game.baseLayer.push(peon2);
  game.baseLayer.push(peon3);
  var enemy = new Peon(130,130,2);
  game.baseLayer.push(enemy);
  setInterval(()=>{
    enemy.moveTo(getRandomArbitrary(0,200), getRandomArbitrary(0,200));
  }, 3000);
  game._intervalId = setInterval(game.run, 1000 / game.fps);
}


function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(2);

class SelectionRectangle extends GameObject {
  constructor(game) {
    super(0,0,0,0);
    this.game = game;
    this.draw = (ctx,viewport) => {
      if(!this.visible){ return; }
      ctx.strokeStyle='red';
      ctx.lineWidth=1;
      var translatedPos = viewport.convertMapCoordsToDisplayCoords(this.x,this.y);
      ctx.strokeRect(translatedPos.x,translatedPos.y,this.w,this.h);
    };

    this.holding = false;
    this.handleDown = coords => {
      if(!this.holding){
        this.holding = true;
        this.x = coords.x;
        this.y = coords.y;
        this.visible = true;
      }
    }
    document.onmouseup = event => {
      if(event.which == 3){ return;} //right click
      if(this.holding){
        this.game.selectObjectsInRect(this.x,this.y,this.h,this.w, game.localPlayer);
        this.visible = false;
        this.x = 0;
        this.y = 0;
        this.h = 0;
        this.w = 0;
        this.holding = false;
      }
    }
    this.handleMove = coords =>{
      if(this.visible){
        this.w = coords.x - this.x;
        this.h = coords.y - this.y;
        return true;
      }
      return false;
    }

  }
}

module.exports = SelectionRectangle;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var Rectangle = __webpack_require__(6);

class GameObject {
  constructor(x,y,h,w,owner) {
    this.position = new Rectangle(x,y,h,w);
    this.size = {w,h};
    this.visible = false;
    this.owner = owner;
    this.update = () => {
      return this.position;
    };
    this.draw = (ctx, mapper) => {
    };
    this.printPosition = () => {
        console.log('at ' + this.position.x + ','+this.position.y);
    };
    this.rightClickAction = event => {
      console.log('right click');
    }
    this.select = () => {
      console.log('select');
    }
    this.deselect = () => {
      console.log('deselect');
    }
    this.alive = () => {
      return true;
    }
  }
}
module.exports = GameObject;


/***/ }),
/* 3 */
/***/ (function(module, exports) {


module.exports.getCanvasCoords = function(event, canvas) {
  var style = canvas.currentStyle || window.getComputedStyle(canvas);
  var leftMargin = style.marginLeft.slice(0, -2);
  var topMargin = style.marginTop.slice(0, -2);
  var modelX = Math.round( (event.clientX- leftMargin) * (canvas.width / canvas.offsetWidth));
  var modelY = Math.round( (event.clientY - topMargin) * (canvas.height / canvas.offsetHeight));
  return {x:modelX, y:modelY};
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var utils = __webpack_require__(3);
var SelectionRectangle = __webpack_require__(1);
var Rectangle = __webpack_require__(6);
var Viewport = __webpack_require__(7);
var Map = __webpack_require__(8);

module.exports = function Game(canvas){
  this.canvas = canvas;
  this.map = new Map(300,300);
  this.viewport = new Viewport(canvas, this.map, {x:100,y:100});
  this.ctx = canvas.getContext('2d');
  //this.ctx.translate(0.5, 0.5);
  this.localPlayer = 1;
  this.fps = 50;
  this.baseLayer = [];
  this.topLayer = [];
  this.selected = [];
  this.update = () => {
    this.baseLayer = this.baseLayer.filter(o => {return o.alive();});
    this.baseLayer.forEach(obj => {
      var preUpdatePosition = new Rectangle(obj.position.x,obj.position.y,obj.position.h,obj.position.w);
      var newPosition = obj.update();
      //check map collision
      if(!this.map.isObjectInside(newPosition)){
        obj.position = preUpdatePosition;
        return;
      }
      var insersects = false;
      this.baseLayer.forEach(other =>{
        if(other === obj || insersects){ return;}
        if(obj.position.intersectRect(other.position)){
          obj.position = preUpdatePosition;
        }
      });
    });
    this.topLayer = this.topLayer.filter(o => {return o.alive();});
    this.topLayer.forEach(obj => {
      obj.update();
    });
  }
  this.draw = () => {
    this.ctx.clearRect(-0.5, -0.5, this.canvas.width, this.canvas.height);
    var context = this.ctx;
    this.baseLayer.forEach(obj => {
      obj.draw(context, this.viewport);
    });
    this.topLayer.forEach(obj => {
      obj.draw(context, this.viewport);
    });
  }
  this.run = () => {
    this.update();
    this.draw();
    this.viewport.updateScroll();
  };

  this.selectObjectsInRect = (x,y,h,w,player) => {

    //var translatedPosition = this.viewport.convertMapCoordsToDisplayCoords(x, y);
    this.selected.map(obj =>{ obj.deselect(); });
    this.selected.length = 0;
    var selectionRect = new Rectangle(x,y,h,w);
    var toSelect = this.baseLayer.filter(obj => {
      return obj.owner == player && selectionRect.intersectRect(obj.position);
    });
    toSelect.forEach(obj => { obj.select(); });
    this.selected.push(...toSelect)
  }

  document.onmousedown = event => {
    var canvasCoords = utils.getCanvasCoords(event, this.canvas);
    var coords = this.viewport.convertDisplayCoordsToMapCoords(canvasCoords.x,canvasCoords.y)
    if(event.which !== 3){
      this.selectionRectangle.handleDown(coords);
      return;
    }
    if(event.which == 3){
      //do right click actions here
      var affectedObject = this.baseLayer.find(obj => { return obj.position.contains(coords.x, coords.y); })
      this.selected.forEach(obj => {
        obj.rightClickAction(coords, affectedObject);
      })
    }
  }
  document.onmousemove = event => {
    var coords = utils.getCanvasCoords(event, this.canvas);
    var translatedCoords = this.viewport.convertDisplayCoordsToMapCoords(coords.x,coords.y)
    if(!this.selectionRectangle.handleMove(translatedCoords)){
      this.viewport.handleMove(coords);
    }
  }
  this.selectionRectangle = new SelectionRectangle(this);
  this.topLayer.push(this.selectionRectangle);
  this.topLayer.push(this.map)
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(2);

class Peon extends GameObject {
  constructor(x,y, owner) {
    super(x,y,15,15, owner);
    this.color = 'blue';
    this.moving = 0;
    this.speedFactor = 0.9; //movement per update
    this.visible = true;
    this.directionX = 0;
    this.directionY = 0;
    this.currentWaypoints = [];
    this.range = 20;
    this.damage = 5;
    this.hitpoints = 100;
    this.lastAttack = 0;
    this.secondsPerAttack = 0.4;
    this.draw = (ctx, viewport) => {
      if(!this.visible){ return; }
      ctx.fillStyle=this.color;
      var translatedPosition = viewport.convertMapCoordsToDisplayCoords(this.position.x, this.position.y);
      ctx.fillRect(translatedPosition.x,translatedPosition.y,this.position.h,this.position.w);
    };

    this.update = () => {
      if(this.target){
        this.moveTo(this.target.position.x, this.target.position.y);
        this.tryAttack();
      }
      if(this.currentWaypoints.length > 0){
        this.moveTowards(this.currentWaypoints[0].x, this.currentWaypoints[0].y);
      }
      return this.position;
    };
    this.moveTo = (x,y) => {
      //todo calculate a non/blocking set of waypoints to x,y
      this.currentWaypoints.length = 0;
      this.currentWaypoints.push({x,y});
    };
    this.moveTowards = (x,y) => {
      var isAtX = Math.abs(this.position.x - x) < 0.5;
      var isAtY = Math.abs(this.position.y - y) < 0.5;
      if( isAtX && isAtY){
        this.currentWaypoints.splice(0,1);
        return;
      }
      if(!isAtX){
        this.position.x += this.speedFactor * (this.position.x > x ? -1 : 1);
      }
      if(!isAtY){
        this.position.y += this.speedFactor * (this.position.y > y ? -1 : 1);
      }
    }

    this.tryAttack = () => {
      var xInRange = Math.abs(this.position.middleX() - this.target.position.middleX()) <= this.range;
      var yInRange = Math.abs(this.position.middleY() - this.target.position.middleY()) <= this.range;
      var attackSpeedTimerUp = (Date.now() - this.lastAttack) /1000 > this.secondsPerAttack;
      if( xInRange && yInRange && attackSpeedTimerUp){
        this.currentWaypoints.splice(0,1);
        this.attackCurrentTarget();
        return;
      }
    }

    this.attackCurrentTarget = () => {
      if(this.target.alive()){
        this.target.hit(this.damage);
        this.lastAttack = Date.now();
        if(!this.target.alive()){
          this.target = null;
        }
      }
    }

    this.hit = dmg => {
      console.log('hit for ' + dmg + ' damage');
      this.hitpoints -= dmg;
    }

    this.alive = () => {
      return this.hitpoints > 0;
    }

    this.attackTo = object => {
      this.color = 'red';
      this.target = object;
      this.moveTo(this.target.position.x, this.target.position.y);
    }

    this.rightClickAction = (pos,object) =>{
      if(object){
        if(object.owner != this.owner){
          this.attackTo(object);
          return;
        }
      }
      this.target = null;
      this.color = 'green';
      this.moveTo(pos.x, pos.y);
    }

    this.select = () => {
      this.color = 'green';
    }

    this.deselect = () => {
      this.color = 'blue';
    }
  }
}

module.exports = Peon;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = function Rectangle(x,y,h,w){
  this.h = h;
  this.w = w;
  this.x = x;
  this.y = y;
  this.left = () => { return this.w < 0 ? this.x + this.w : this.x;};
  this.top = () => { return this.h < 0 ? this.y + this.h : this.y;};
  this.bottom = () => { return this.h < 0 ? this.y : this.y + this.h;};
  this.right = () => { return this.w < 0 ? this.x :  this.x + this.w;};
  this.middleX = () => { return this.left() + ((this.right() - this.left()) /2);};
  this.middleY = () => { return this.left() + ((this.bottom() - this.top()) /2);};

  this.contains = (x,y) =>{
    return this.left() <= x && x <= this.right() &&
           this.top() <= y && y <= this.bottom();
  }
  this.intersectRect = function(other) {
    return !(other.left() > this.right() ||
             other.right() < this.left() ||
             other.top() > this.bottom() ||
             other.bottom() < this.top());
  }
}


/***/ }),
/* 7 */
/***/ (function(module, exports) {


module.exports = function Viewport(canvas, map, startCorner){

  this.map = map;
  this.canvas = canvas;
  this.scrollSpeed = 2;
  this.viewportCorner = {x:startCorner.x,y:startCorner.y};
  this.convertMapCoordsToDisplayCoords = (x,y) => {
    return {x:(x - this.viewportCorner.x), y:(y-this.viewportCorner.y)};
  }

  this.convertDisplayCoordsToMapCoords = (x,y) => {
    return {x:(x + this.viewportCorner.x), y:(y+this.viewportCorner.y)};
  }

  this.updateScroll = () => {
    var scrollMargin = 30;
    if(this.mouseX > canvas.width - scrollMargin && this.mouseX < canvas.width){ this.scrollRight();}
    if(this.mouseY > canvas.height - scrollMargin && this.mouseY < canvas.height){ this.scrollDown();}
    if(this.mouseX < scrollMargin && this.mouseX > 0){ this.scrollLeft();}
    if(this.mouseY < scrollMargin && this.mouseY > 0){ this.scrollUp();}
  }

  this.handleMove = coords =>{
    this.mouseX = coords.x;
    this.mouseY = coords.y;
  }

  this.scrollRight = () => {
    this.scroll(this.scrollSpeed,0);
  }

  this.scrollDown = () => {
    this.scroll(0,this.scrollSpeed);
  }

  this.scrollLeft = () => {
    this.scroll(-this.scrollSpeed,0);
  }

  this.scrollUp = () => {
    this.scroll(0,-this.scrollSpeed);
  }

  this.scroll = (x,y) => {
    if(this.viewportCorner.x < -50 && x < 0){
      //skip x
    }
    else if(this.viewportCorner.x + this.canvas.width -50 > this.map.position.w && x > 0){
      //skip x
    } else{
      this.viewportCorner.x += x;
    }

    if(this.viewportCorner.y < -25 && y < 0){
      //skip y
    }
    else if(this.viewportCorner.y + this.canvas.height - 25 > this.map.position.h && y > 0){
      //skip y
    } else{
      this.viewportCorner.y += y;
    }
  }
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var GameObject = __webpack_require__(2);

class Map extends GameObject {
  constructor(h,w) {
    super(0,0,h,w);
    this.color = 'black';
    this.visible = true;
    this.draw = (ctx, viewport) => {
      if(!this.visible){ return; }
      ctx.strokeStyle=this.color;
      var translatedPosition = viewport.convertMapCoordsToDisplayCoords(this.position.x, this.position.y);
      ctx.strokeRect(translatedPosition.x,translatedPosition.y,this.position.h,this.position.w);
    };

    this.isObjectInside = position =>{
      if(position.x < 0  || position.x + position.w > this.position.w){return false;}
      if(position.y < 0  || position.y + position.h > this.position.h){return false;}
      return true;
    }
  }
}

module.exports = Map;


/***/ })
/******/ ]);